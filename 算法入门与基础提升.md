# 算法入门与基础提升

**写在开头**：

算法是不分语言的，但从刷题的角度来说，不推荐脚本语言，如Python和PHP。这是因为脚本语言的系统API过多，这导致你认为的很多常数时间的操作，实际上不上常数时间，难以估计算法复杂度。推荐使用Java或者C++来刷题，两者中首推C++，因为C++操作的常数时间特别好。Java的好处在于，脚本语言和非脚本语言的用户都能看懂。

## 第1章 认识复杂度和简单排序算法

### 1.1 时间复杂度

#### 1.1.1 常数时间的操作与不是常数时间的操作

所谓常数时间的操作，就是一个与数据量无关的时间的操作。

常数时间操作包括：

- 基本运算：加、减、乘、除
- 移位操作：左移、右移
- 逻辑运算：与、或、非、异或、同或
- 数组寻址：寻找arr[i]的值

不是常数时间的操作，其操作消耗的时间与数据量有关。比如：

- 遍历一个数组（与数组元素个数有关）
- 查找单链表（与单链表元素个数有关）

#### 1.1.2 时间复杂度

**时间复杂度**是指执行一个算法流程，需要经历多少个常数时间的操作。

也就是常数时间操作的次数。

这个次数可以用$O$来描述。

比如选择排序，其常数时间操作的次数可以写成$aN^2+bN+c$

> 在表达式中，只要高阶项，不要低阶项，省略高阶项的系数a，用剩下的部分描述时间复杂度。

也就是$O(N^2)$

> 时间复杂度粗描了算法流程耗时与数据量的关系。

**时间复杂度从好到坏：**

- $O(1)<O(logN)<O(N)<O(N^2)<...<O(N^k)$
- $O(2^N)<O(3^N)<...O(k^N)<O(N!)$ 

> $O(N!)$是指暴力组合的方法，穷举所有组合情况
>
> $O(logN)$默认以2为底



#### 1.1.3 评价一个算法流程的好坏的方法

比较两个算法流程的好坏有以下两个方法：

1. 先看时间复杂度的指标。
2. 再分析不同数据样本下的实际运行时间。（也就是通过做实验的方法，比较两个时间复杂度指标相同的算法具体的耗时情况）

### 1.2 额外空间复杂度

额外空间复杂度是指，算法流程在执行的过程中，要申请多少额外的空间。

> 如果多的是几个变量，那么额外空间复杂度是$O(1)$

### 1.3 冒泡排序、选择排序

 #### 1.3.1 冒泡排序

时间复杂度： $O(N^2)$

额外空间复杂度： $O(1)$

#### 1.3.2 选择排序

时间复杂度：$O(N^2)$

额外空间复杂度： $O(1)$

```java
public static void selectionSort(int[] arr){
    if (arr==null||arr.length<2){
        return;
    }
    for (int i=0;i<arr.length-1;i++){
        int minIndex=i;
        for (int j=i+1;j<arr.length;j++){
            minIndex=arr[i]<arr[minIndex]?:minIndex;
        }
        swap(arr,i,minIndex);
    }
}
```

### 1.4 插入排序的细节和时间复杂度分析

冒泡排序、选择排序的算法流程与数据状况无关，是严格的算法流程。而插入排序不是。

插入排序的思路：

以一个含有6个元素的数组举个例子：[3 4 1 2 5 0]

1. 实现0~0范围有序
2. 实现0~1范围有序
3. 实现0~2范围有序
4. 实现0~3范围有序
5. ...
6. 实现0~6范围有序

时间复杂度：$O(N^2)$ 

> 上述时间复杂度按照最差状况估计，虽然和选择排序和冒泡排序相同，但是因为插入排序的最差情况如此，实际中耗时只会比它小不会比它大，所以在常数个数据的条件下插入排序要比选择排序、冒泡排序快。

### 1.5 二分法的使用和复杂度分析

二分法是一种查找方法。原始的查找方法是**遍历查找**，时间复杂度为$O(N)$。如果数组处于**有序**的状态，可以通过二分查找法来快速查找。

| 方法 |    时间复杂度  |
| :--: | :--: |
|  二分法    | $O(log_2N)$ |
| 遍历查找 | $O(N) $ |

> 时间复杂度：每次砍一半，要砍多少次

下面列举三个二分法的例子

#### 1.5.1 问题1 在一个有序数组中，找某个数是否存在

算法思路:在有序数组中

- 每次砍一半，直到剩下一个。
- 如果有要找的，最后这个就是或者之前已经找到了。
- 如果到最后一个仍不是，那就没有。

#### 1.5.2 问题2 在一个有序数组中，找>=某个数最左侧的位置

1. 问题描述
   在一个有序数组中，如何找到>=2最左的位置：
   array=[0011222222223333333]

2. 解题思路

   - 从中间位置开始
   - 设置一个全局变量index标记最左的位置
   - 判断这个数是不是满足>=2; 

     1. 满足:比较当前下标与index标记的关系，保留更左边的那个，左移 

     2. 不满足:右移
   - 这个过程一直持续到二分彻底完成， 之后返回满足条件的最左的位置的数，也就是array[index]。整个过程中index一直标记最左侧的位置。

#### 1.5.3 问题3 局部最小值问题——二分法必须要有序吗？

1. 问题描述：

   局部最小值：

   - 如果$arr[0]<arr[1]$，则认为$arr[0]$是局部最小值（最左边的数）
   - 如果$arr[N-1]<arr[N-2]$，则认为$arr[N-1]$是局部最小值(最右边的数)
   - 如果$arr[i-1]>arr[i]<arr[i+1]$，$arr[i]$是局部最小值（中间的数）

   给出一个数组$arr$，任意两个相邻的元素不相等，请返回**任意一个**局部最小值。

1. 解题思路：

   - 看$arr[0]$和$arr[N-1]$的值是不是局部最小的

   - 如果上述两个都不是，也就是说

     $$arr[0]>arr[1] 且 arr[N-2]<arr[N-1]$$

     变化趋势从下降变成上升，则arr[1]和arr[N-2]之间必存在局部最小

   - 二分法：比较$arr[M-1]，arr[M]，arr[M+1]$

     如果$arr[M-1]<arr[M]$，向左收缩；

     如果$arr[M-1]\geq arr[M]$，如果$arr[M]<arr[M+1]$，$arr[M]$是局部最小值，如果$arr[M]>=arr[M+1]$，向右收缩。

> 优化问题的两个思路：
>
> 1. 优化数据状况（利用数据状况）
> 2. 优化问题性质（本题目是只要返回一个就行）
>
> 最优解往往是优化数据状况，结合问题优化问题性质呈现的解法
>
> （实战课程）


### 1.6 一道时间复杂度很低的利用异或运算解决的问题

#### 1.6.1 异或运算的性质与扩展

1. 异或运算：相同为0不同为1，**本质上是无进位相加**。

2. 基本性质：
   >0^N==N
   >
   > N^N==0
   >
   > 0^0==0
   
3. 满足交换律和结合律

   > a^b = b^a
   >
   > a ^ b ^c = a^ (b ^c)  

   异或讨论某一位上1的个数**是奇还是偶**的问题（偶数个为0，奇数个为1）。因此一大堆数异或，谁先谁后无所谓。

#### 1.6.2 不用额外变量交换两个数

1. 题目描述：

   有两个整数a,b，在不申请额外变量的前提下交换两个数。

2. 解题方法：

   ```python
   int a=10,int b=2
   a=a^b       #a=10^2,b=2
   b=a^b		#a=10^2,b=10^2^2=10
   a=a^b		#a=10^2^10=2,b=10
   ```

   常规的方法如下：
   
   ```java
   int a=10,int b=2
   int tmp
   tmp=a
   a=b
   b=tmp
   ```
   
   C++中的交换函数
   
   ```c++
   void swap(int *a,int *b)
   {
   	*a=*a^*b;
       *b=*a^*b;
       *a=*a^*b;
   }
   ```
   
   

#### 1.6.3 找出数组中出现奇数次的数

1. 题目描述：

   在一个数组`arr`中，只有一种数出现了奇数次，剩下所有的数都出现了偶数次，请找出这个出现了奇数次的数。

2. 解题方法：

   一般来讲，是通过词频统计，用额外数据结构记录词频，返回出现奇数次的数。

   用异或的方法，只要遍历一次就可以找出。

   - 申请变量`eor=0`
   - 用`eor`依次异或`arr`中的每一个数，得到的结果就是出现了奇数次的数。

#### 1.6.4 找出数组中两种出现奇数次的数

1. 题目描述：

   一个数组`arr`中，有两种数出现了奇数次，其他数都出现了偶数次，怎么找到这两个数。

2. 解题方法：

   假设这两个数是`a`和`b`。

   - 申请变量`eor=0`
   - 用`eor`依次异或`arr`中的每一个数，得到结果`eor=a^b`
   - 因为$a\neq b$,所以$eor\neq 0$。那么`eor`中一定至少有一位为1。我们选取最右边的那个1，假设是从右边数第`m`位。
   - m位为1，意味着a和b在第m位，一个是1，一个是0。那么接下来我们可以把整个数组分为**第m位为1**的和**第m位为0**的两类。
   - 申请变量`eor'`
   - 用`eor'`依次异或**第m位为1**的数。因为除了a和b，其他数都是偶数个，那么异或的结果是a和b中的某一个。假如计算的结果是$eor'=b$
   - `eor`和`eor'`的异或结果是a

3. 代码技巧：

   ```java
   //arr中一定有两种数出现了奇数次，其他数都出现了偶数次
   //注意提出最右边的1的操作
   
   public static void printOddTimesNum2(int[] arr){
       int eor=0;
       for (int i=0;i<arr.length;i++){
           eor^=arr[i];
       }
       //eor=a^b
       //eor!=0
       //eor必然至少有一个位置上是1
   }
   	int rightOne=eor&(~eor+1); //提出最右边的1。与上自身取反加一
   	int onlyOne=0; //eor'
   //再次遍历arr中的每一个数，把与rightOne与完不为0的数提出来与onlyOne异或
   	for (int cur=0;cur<arr.length;cur++){
           if((arr[cur]&rightOne)!=0) {  //判断是不是这一位是1
               onlyOne^=arr[cur];
           }
       }
   ```

### 1.7 详解对数器的使用

对数器用于测试一种方法是不是可以使用。

假设待测方法的A，另有一种正确的方法B（可能是暴力方法）

我们设置大量的随机输入样本，之后比较两种算法得到的结果a,b

如果经过大量的数据测试，每一组都满足$a=b$，则我们可以说A方法是可信的。

> oj测试的例子也是人想出来的，只有在刷题的时候使用的。实际测试的时候要使用对数器。
>
> - 比oj更稳，更容易定位错误
> - 可以创造大样本

```java
//已有绝对正确的暴力方法comparator,验证选择排序算法selectionSort
public static void comparator(int[] arr){
    Arrays.sort(arr);
}

//随机输入发生器
public static int[] generateRandomArray(int maxSize,int maxValue){
    //每一种语言都有生成随机数的方法
    //Math.random()->[0,1) double
    //对于计算机来说，[0,1)上的小数的数量是有限的，random是等概率返回
    //Math.random()*A->[0,A) double A->int
    //(int)(Math.random()*A)->[0,A-1] int
    int[] arr=new int[(int)((maxSize+1)*Math.random())];
    for int i=0;i<arr.length;i++{
        arr[i]=(int)((maxValue+1)*Math.random())-(int)(maxValue*Math.random())
    }
    return arr;
}
// 对数器测试
public static void main(String[] args){
    //设置测试参数范围
    int testTime=500000;
    int maxSize=100;
    int maxValue=100;
    boolen succeed=true;
    //获取输入输出
    for (int i=0;i<testTime;i++){
        //输入
        int[] arr1=generateRandomArray(maxSize,maxValue);
        int[] arr2=copyArray(arr1);
        //输出
        selectionSort(arr1);
        comparator(arr2);
        //比较，发现不一样的输出并修改标记，便于调试
        if (!isEqual(arr1,arr2)){
            succeed=false;
            printArray(arr1);
            printArray(arr2);
            break;
        }
    }
}
```

**对数器的模板要背下来，笔试的时候可以使用。**

### 1.8 递归行为和递归行为时间复杂度的估算

#### 1.8.1 递归行为

举个例子：用递归的方法找到一个数组中的最大值。

```java
//用递归的形式在arr上找Max
//分两部分，分别找出Max左和Max右
public static int getMax(int[] arr){
    if(arr == null||arr.length==0){
        //没有数，给用户报错
    }
    return process(arr,0,arr.length-1); //找0~N-1上的最大值，返回
}
//arr[L..R]范围上求最大值
public static int porcess(int[] arr,int L,int R){
    if (L==R){
        //arr[L..R]范围上只有一个数，直接返回,basecase
        return arr[L];
    }
    //mid=(L+R)/2
    //mid=L+(R-L)/2
    int mid=L+((R-L)>>1);  //找到R与L的终点
    int leftMax=process(arr,L,mid);
    int rightMax=process(arr,mid+1,R);
    return Math.max(leftMax,rightMax);
}
```

- 递归要有`basecase`，用来说明，递归到什么程度就不再递归了。
- 求中点写成`mid=L+((R-L)>>1)`是为了防止R和L比较大的时候会造成溢出。
- 写代码前，画出递归的决策树。

#### 1.8.2 递归行为复杂度估计范式

不是针对具体的某一个递归算法，而是对递归行为整体进行剖析。

**Master公式**

> $T(N)=aT(\frac{N}{b})+O(N^d)$
>
> 描述了一类递归：
>
> 每次缩小的规模都是$\frac{N}{b}$，一次调用中递归的过程重复了$a$次。除了递归之外，余下的过程可以描绘为$O(N^d)$

不符合Master公式的模型：子问题不是等规模的

> 每次切分，从前$\frac{1}{3}$处切分，也就是每次切成1:2的两部分
>
> $$T(N)=T(\frac{N}{3})+T(\frac{2}{3}N)+O(1)$$
>
> 不符合Master公式的模型

对于符合Master公式的模型来说：

> $T(N)=aT(\frac{N}{b})+O(N^d)$
>
> 1. 如果$log_ba$<d，算法时间复杂度为$O(N^d)$
> 2. 如果$log_ba$>d，算法时间复杂度为$O(N^{log_ba})$
> 3. 如果$log_ba$==d，算法时间复杂度为$O(N^d*logN)$

对于上述查找算法来说：

> $T(N)=2T(\frac{N}{2})+O(1)$
>
> $log_ba==log_22=1$,$d=0$
>
> 所以该算法的时间复杂度为$O(N)$



## 第2章 认识$O(N*logN)$的排序

|           排序算法           |  时间复杂度  |
| :--------------------------: | :----------: |
|  归并排序、堆排序、快速排序  | $O(N*logN) $ |
| 选择排序、冒泡排序、插入排序 |  $O(N^2) $   |

以上六种算法都是**基于比较的排序算法**，第三章有不基于比较的排序算法的讲解。

### 2.1 归并排序详解

#### 2.1.1 用递归的方法实现递归排序

1. 算法思想：

   - 对数组arr[L,R]进行排序，记为P(L,R)。
   - 将数组拆分为左右两部分：arr[L,M]和arr[M+1,R]，分别对两部分排序，记为P(L,M),P(M+1,R)，让两部分有序。
   - 依次拆分，指导仅剩下一个数。
   - 逐次合并成有序数组。

   合并的方法：

   - 创建一个和合并的数组长度等大的空间，比较两个子数组的数，谁小拷贝谁。
   - 排好序后把新数组中的数拷贝回原数组。

2. 递归的方法实现：

   ```java
   //主程序，判断特殊情况，并执行排序
   public static void mergeSort(int[] arr){
   	if (arr==null||arr.length<2){
           return;
       }
       process(arr,0,arr.length-1);
   }
   
   //归并排序算法，另arr[L..R]有序
   public static void process(int[] arr,int L,int R){
       if (L==R){		//basecase
           return;
       }
       int mid=L+((R-L)>>1);//取中点
       process(arr,L,mid);
       process(arr,mid+1,R);
       merge(arr,L,mid,R);//合并算法
   }
   //合并两段有序的数组
   public static void merge(int[] arr,int L,int M,int R){
       int[] help=new int[R-L+1];
       int i=0;
       int p1=L;		//左部分的指针
       int p2=M+1;     //右部分的指针
       while(p1<=M && p2<=R){  //两部分都没有越界
     	  help[i++]=arr[p1]<=arr[p2]?arr[p1++]:arr[p2++];
       }
       //下面两个while虽然顺序写，但只有一个会执行
       while(p1<=M){
         help[i++]=arr[p1++];       
           }
       while (p2<=R){
         help[i++]=arr[p2++]
           }
   }
   ```

**时间复杂度：**

$T(N)=2T(\frac{N}{2}+O(N))$ -> $O(N*logN)$

**额外空间复杂度：**

$O(N)$ 

**如何达到这种优化效果的？**

$O(N^2)$的算法大量的浪费了比较次数，而归并排序将每一个子部分都变成有序的状态，这样在后续的比较中可以跳过一些不必比较的部分。

#### 2.1.2 用非递归的方法实现归并排序

1. 算法思想：

   - 数组[3,6,2,0,7,9,4,0,5,2,3]。
   - P代表merge的范围，P=1代表相邻的两个数进行merge，也就是merge([3],[6]),merge([2],[0]),merge([7],[9]),merge([4],[0]),merge([5],[2]),merge([3])。得到结果为[3,6,0,2,7,9,0,4,2,5,3]。
   - P=4,merge([3,6],[0,2]),merge([7,9],[0,4]),merge([2,5],[3])。得到结果为[0,2,3,6,0,4,7,9,2,3,5]。
   - P=8,得到结果为[0,0,2,3,4,6,7,9,2,3,5]。
   - P=16,得到结果为[0,0,2,2,3,3,4,5,6,7,9]。

2. 时间复杂度分析；

   非递归的形式可以直观的看出来$O(N*logN)$的时间复杂度。（非递归不能用Marster公式。

   - 要进行多少轮merge？ $O(logN)$
   - 每次merge要多少次比较？$O(N )$

### 2.2 归并排序的扩展

#### 2.2.1 小和问题

1. 问题描述：

   在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组的小和。

2. 粒子：

   给定数组[1,3,4,2,5] 

   - 1 左边比1小的数，没有
   - 3左边比3小的数，1
   - 4左边比4小的数，1,3
   - 2左边比2小的数，1
   - 5左边比5小的数，1,3,4,2

   所以这个数组的小和为$1+1+3+1+1+3+4+2=16$

3. 解题思路：

   这个问题可以从**求每个数左边比本身小的数分别是什么**转换为**求这个数右边有多少个数比其本身大**。

   - 拆分成[1,3,4]和[2,5]两部分。
   - [1,3,4]拆分成[1,3]和[4]两部分。
   - [1,3]拆分成[1]和[3]。
   - 合并[1]和[3]。读入1的时候，右边数组有一个数比1大，在`1~1`的范围上获得`1个1`。
   - 合并[1,3]和[4]。读入1时，右边数组有一个数比1 大，在`2~2`的范围上获得`1个1`。读入3的时，右边数组有一个数比3大，在`2~2`的范围上获得`1个3`。
   - [2,5]拆分成[2]和[5]。
   - 合并[2]和[5]。读入2时，右边数组有一个数比2大，在`4~4`的范围上获得`1个2`。
   - 合并[1,3,4]和[2,5]。读入1时，右边数组有两个数比1大，在`3~4`的范围上获得`2个1`。读入3时，右边数组有一个数比3大，在`3~4`的范围上获得`1个3`。读入4时，右边数组有一个数比4大，在`3~4`的范围上获得`1个4`。
   - 用一个全局变量将上述过程获得的数累加起来得到结果。

   特殊情况：左边的部分和右边的部分有数相等怎么办？[2,3,6,7,3,4,8,9]

   相等的时候，**先拷贝右组的数。**即[2,3,6,7]和[3,4,8,9]合并的时候，先拷贝右边数组里面的3，之后比较左边的3和右边的4。这是小和问题中的归并排序和经典归并排序唯一不同的地方。

   > 思考题：[2,2,2,2,3,3,3,3,3]与[2,2,3,3,4,4,6]合并的过程。

4. 算法代码：

   ```Java
   //arr[L..R]排好序，并求小和。在经典排序的基础上进行改写。
   public static int smallSum(int[] arr){
       if (arr==null||arr.length<2){
           return 0;  //返回数字
       }
    return process(arr,0,arr.length-1);
   }
   
   //排序，并返回区间上的小和
   public static int process(int[] arr,int L,int R){
       if(L=R){
           return 0;     
       }
       int mid=L+((R-L)>>1);
       return process(arr,L,mid)
           +process(arr,mid+1,R)
           +merge(arr,L,mid,R);
   } 
   //相对于经典算法，多了三行
   public static int merge(int[] arr,int L,int m,int r){
       int[] help=new int[r-L+1];
       int i=0;
       int p1=L;
       int p2=m+1;
       int res=0;        //记录小和【1】
       while (p1<=m && p2<=r){
           //arr[p1]是当前左组的数
           //(r-p2+1)是右组中比arr[p1]大的数的个数
          res+=arr[p1]<arr[p2]?(r-p2+1)*arr[p1]:0;//【2】
           //经典算法中的<=在这里被修改成严格<
          help[i++]=arr[p1]<arr[p2]?arr[p1++]:arr[p2++];
       }
       while(p1<=m){
           help[i++]=arr[p1++];
       }
       while(p2<=r){
           help[i++]=arr[p2++];
       }
       for(i=0;i<help.length;i++){
           arr[L+i]=help[i];
       }
       return res;//【3】
   }
   
   ```
   

#### 2.2.2 逆序对问题

1. 问题描述：

   在一个数组中，左边的数如果比右边的数大，则这两个数构成一个逆序对。请返回逆序对的数量。

2. 例子：

   数组[5,3,6,7,9,0]。逆序对有[5,3],[5,0],[3,0],[6,0],[7,0],[9,0]。
   
3. 解析：

   逆序对问题和小和问题其实是同一个类型的问题；

   - 小和问题：一个数右边有多少个数比自身大？
   - 逆序对问题：一个数左边有多少个数比自身小？
   

**小和问题和逆序对问题每年面试/笔试都出现。**

### 2.3 堆结构和堆排序详解

#### 2.3.1 什么是堆？

堆是指一个黑盒，要提供两个操作：

1. add：添加元素操作
2. popmax：找出最大值，弹出并删除

要求两个方法单独执行的时候，时间复杂度要尽可能低。

#### 2.3.2 堆结构

堆结构可以从两个维度来考虑：

1. 在脑海中：具有特殊标准的完全二叉树
2. 在物理上：通过数组实现

> 什么是完全二叉树？
>
> 首先是二叉树
>
> 其次是满的二叉树
>
> 如果不满，也是处于逐渐变满的过程
>
> 完全二叉树可以用一个从零出发的连续数组描述。
>
> 对于处于i位置的某一个元素来说，对任一位置i：
>
> - 左子的位置为$2\times i+1$
>
> - 右子的位置为$2\times i+2$
>
> - 父节点的位置为$\frac{i-1}{2}$。
>
> 如果弃用数组的0位置，即令数组从1开始，则对于任一位置i来说：
>
> - 左子的位置$2\times i$
>
> - 右子的位置$2\times i+1$
>
> - 父节点的位置$\frac{i}{2}$
>
> 这样，依次在数组中放置数字，实际上就是按照二叉树的顺序在增长。

堆除了满足是完全二叉树的条件之外，还要满足另外一个条件，这个条件根据堆的种类有所不同。

1. 大根堆：每一个子树的最大值，都是子树的头节点。（对任一子树都成立）
2. 小根堆：每一个子树的最小值，都是子树的头节点。（对任一子树都成立）

下面说堆的两个操作:插入操作和popmax操作。

1. 插入操作：

   讨论插入操作是在这样一个前提条件下：

   数组每次输入一个数，每输入一个数都要保证数组呈现大根堆的排列规则。

   在这样的条件下，每次得到的新数都需要执行下方操作，称为`heapinsert`：

   - 将新得到的数与其父节点比较，如果比父节点大，就和父节点交换，如果比父节点小，就保持不变。
   - 这个过程持续到新数比父节点小，或者达到数组的首位。

   组织成这样的形式，进行popmax操作的时候会比较方便。

2. popmax操作：

   popmax的内容包括弹出最大值并返回，同时删除最大值，并把

   以数组[8,7,5,6,4,3]为例：

   

 

#### 2.3.3 堆排序





### 2.4 荷兰国旗问题

#### 2.4.1 问题一

给定一个数组arr，和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求额外空间复杂度$O(1)$，时间复杂度$O(N)$。

**思路：**

额外空间复杂度$O(1)$说明不能用额外的数组空间，要在原数组上进行操作。

- 将数组分成两个部分：前面的是<=num的区域，后面是>num的区域。
- 指针从第一个数开始，往后移。
  - 如果<=num，与<=区域后一个数交换，<=区右扩一位
  - 如果>num，指向下一个数
- 流程持续到数组遍历完成。

#### 2.4.2 问题二（荷兰国旗问题）

给定一个数组arr，和一个数num，请把小于num的数放在数组的左边，等于num的数放在数组的中间，大于num的数放在数组的右边。要求额外空间复杂度$O(1)$，时间复杂度$O(N)$。

- 

```Java
//在arr[L..R]范围上，根据p分块，<p在左边，==p在中间，>p在右边
//返回值int[]的含义：一定会返回一个长度为2的数组，等于区域的的左边界和右边界
//arr=[...3 5 5 4 6 7...]
//index:  4 5 6 7 8 9
//p=5(划分值)
//arr=[...(34)5 5(67)...]
//index      6 7
//返回[6,7],等于区域的左右边界
//但未必有等于区域，此时返回值左边界>右边界
public static int[] parition(int[] arr,int L,int R,int P){
    //L、R一开始为等于区的左右边界,初始时L指向数组左边，R指向右边
    //less为小于区的右边界
    //more为大于区的左边界
    int less=L-1;	//	<区的右边界
    int more=R+1;	//	>区的左边界
    int index=L;	//	当前数的下标
    while(L<more){ 	
        if(arr[index]<p){
            swap(arr,++less,L++);
        }else if(arr[index]>P){
            swap(arr,--more,index);
        }else {
            index++;
        }
    }
    return new int[]{less+1,more-1};
}
```

```java
//快排1.0
public static int quick_1_0(int[] arr,L,R){
process(arr,0,arr.length-1);
}

public static int porcess(int[] arr,int L,int R){
	//以arr[R]做划分
	//假设最后arr[R]来到了Index位置
    porcess(arr,L,index-1);
    porcess(arr,index+1,R);
}
```

```java
//快排2.0

```

```java
//快排3.0 随机快排
public static void process(int[] arr,int L,int R){
    if(L<R){
        swap(arr,L+(int)Math.random()*(R-L+1)),R);
    	int[] p=partition(arr,L,R);
        process(arr,L,p[0]-1);
        process(arr,p[1]+1,R);
    }  	
}

public static int[] partition(int[] arr,int L,int R){
    int less=L-1;
    int more=R;
    while(L<more){
        if(arr[L])
    }
}
```





### 2.5 快速排序



### 2.6 快速排序的复杂度



## 第3章 详解桶排序 以及排序内容大总结

### 3.1 详解比较器



### 3.2 桶排序思想下的具体排序：计数排序、基数排序



### 3.3 排序内容汇总与常见坑总结



### 3.4 工程上对排序的改进



## 第4章 链表



## 第5章 二叉树



## 第6章 图



## 第7章 详解前缀树和贪心算法



## 第8章 暴力递归



## 第9章 哈希结构：哈希函数与哈希表


## 第10章 有序表与并查集


## 第11章 KMP与Manacher算法


## 第12章 滑动窗口与单调栈结构

## 第13章 二叉树与树形dp

## 第14章 大数据与位运算题目


## 第15章 从暴力递归到动态规划（上）

## 第16章 从暴力递归到动态规划（下）


